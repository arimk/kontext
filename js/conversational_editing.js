document.addEventListener('DOMContentLoaded', () => {
    const chatMessages = document.getElementById('chatMessages');
    const chatTextInput = document.getElementById('chatTextInput');
    const chatSendButton = document.getElementById('chatSendButton');
    const chatAttachImageButton = document.getElementById('chatAttachImageButton');
    const chatImageUpload = document.getElementById('chatImageUpload');
    const chatStartOverButton = document.getElementById('chatStartOverButton');
    const chatAspectRatio = document.getElementById('chatAspectRatio'); // Get aspect ratio dropdown
    const chatModelSelect = document.getElementById('chatModelSelect'); // Get model selection dropdown
    const chatInputArea = document.querySelector('.chat-input-area'); // Get the chat input area

    // Modal elements for chat images
    const chatImageModal = document.getElementById('chatImageModal');
    const chatModalImage = document.getElementById('chatModalImage');
    const chatModalCloseButton = document.getElementById('chatModalCloseButton');
    // const chatModalCaption = document.getElementById('chatModalCaption'); // If using caption

    let isBotTyping = false; // To prevent multiple "typing" messages
    let pendingImageBase64 = null; // To hold user-uploaded image until text is sent
    let lastBotImageUrl = null; // To hold the URL of the last image generated by the bot

    // Function to add a message to the chat window
    function addMessage(text, type, imageUrl = null, meta = null) {
        if (!text && !imageUrl) return null; // Don't add empty messages unless it's an image-only message

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', `${type}-message`);

        if (meta && type === 'bot' && imageUrl) {
            // Store the parameters used for this bot message
            messageDiv.dataset.prompt = meta.text || '';
            messageDiv.dataset.imageContext = meta.imageUrl || '';
            messageDiv.dataset.aspectRatio = meta.aspectRatio || '';
        }

        // Store parameters for user messages that will generate images
        if (type === 'user' && text) {
            // We'll set these parameters when the message is actually sent
            messageDiv.dataset.prompt = text;
            // Don't add edit icon here - we'll add it after parameters are set
        }

        if (text) {
            const textNode = document.createElement('p');
            textNode.textContent = text;
            messageDiv.appendChild(textNode);
        }

        if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = (type === 'user') ? "User uploaded image" : "Bot generated image";
            img.style.maxWidth = '200px';
            img.style.maxHeight = '200px';
            img.style.objectFit = 'contain';
            img.style.borderRadius = '5px';
            img.style.marginTop = text ? '5px' : '0';
            messageDiv.appendChild(img);

            // Add retry icon for bot messages with images
            if (type === 'bot' && imageUrl) {
                const retryIcon = document.createElement('span');
                retryIcon.classList.add('retry-icon');
                retryIcon.title = 'Retry';
                retryIcon.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="0.1" stroke-linecap="round" stroke-linejoin="round"><path xmlns="http://www.w3.org/2000/svg" fill="#000000" d="M14.9547098,7.98576084 L15.0711,7.99552 C15.6179,8.07328 15.9981,8.57957 15.9204,9.12636 C15.6826,10.7983 14.9218,12.3522 13.747,13.5654 C12.5721,14.7785 11.0435,15.5888 9.37999,15.8801 C7.7165,16.1714 6.00349,15.9288 4.48631,15.187 C3.77335,14.8385 3.12082,14.3881 2.5472,13.8537 L1.70711,14.6938 C1.07714,15.3238 3.55271368e-15,14.8776 3.55271368e-15,13.9867 L3.55271368e-15,9.99998 L3.98673,9.99998 C4.87763,9.99998 5.3238,11.0771 4.69383,11.7071 L3.9626,12.4383 C4.38006,12.8181 4.85153,13.1394 5.36475,13.3903 C6.50264,13.9466 7.78739,14.1285 9.03501,13.9101 C10.2826,13.6916 11.4291,13.0839 12.3102,12.174 C13.1914,11.2641 13.762,10.0988 13.9403,8.84476 C14.0181,8.29798 14.5244,7.91776 15.0711,7.99552 L14.9547098,7.98576084 Z M11.5137,0.812976 C12.2279,1.16215 12.8814,1.61349 13.4558,2.14905 L14.2929,1.31193 C14.9229,0.681961 16,1.12813 16,2.01904 L16,6.00001 L12.019,6.00001 C11.1281,6.00001 10.6819,4.92287 11.3119,4.29291 L12.0404,3.56441 C11.6222,3.18346 11.1497,2.86125 10.6353,2.60973 C9.49736,2.05342 8.21261,1.87146 6.96499,2.08994 C5.71737,2.30841 4.57089,2.91611 3.68976,3.82599 C2.80862,4.73586 2.23802,5.90125 2.05969,7.15524 C1.98193,7.70202 1.47564,8.08224 0.928858,8.00448 C0.382075,7.92672 0.00185585,7.42043 0.0796146,6.87364 C0.31739,5.20166 1.07818,3.64782 2.25303,2.43465 C3.42788,1.22148 4.95652,0.411217 6.62001,0.119916 C8.2835,-0.171384 9.99651,0.0712178 11.5137,0.812976 Z"></path></svg>
                `;
                retryIcon.onclick = (e) => {
                    e.stopPropagation();
                    handleRetry(messageDiv);
                };
                messageDiv.appendChild(retryIcon);
            }


        }

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom
        return messageDiv;
    }

    // --- Chat Image Modal Logic ---
    function openChatModal(imageUrl) {
        if (chatImageModal && chatModalImage) {
            chatModalImage.src = imageUrl;
            chatImageModal.style.display = "flex"; // Use flex for centering, or block
             // document.body.style.overflow = 'hidden'; // Prevent background scroll
        }
    }

    function closeChatModal() {
        if (chatImageModal) {
            chatImageModal.style.display = "none";
            chatModalImage.src = ""; // Clear image
            // document.body.style.overflow = 'auto'; // Restore background scroll
        }
    }

    // Event listener for chat messages container to handle clicks on dynamically added images
    if (chatMessages) {
        chatMessages.addEventListener('click', (event) => {
            if (event.target.tagName === 'IMG' && event.target.closest('.message')) {
                // Check if the image is not part of an action button or similar
                // For now, any image in a message is considered viewable.
                openChatModal(event.target.src);
            }
        });
    }

    // Event listener for modal close button
    if (chatModalCloseButton) {
        chatModalCloseButton.addEventListener('click', closeChatModal);
    }

    // Event listener for clicking outside the modal content (on the overlay) to close
    if (chatImageModal) {
        chatImageModal.addEventListener('click', (event) => {
            if (event.target === chatImageModal) { // Clicked on the overlay itself
                closeChatModal();
            }
        });
    }
    // Optional: Close modal on 'Escape' key press
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && chatImageModal && chatImageModal.style.display !== 'none') {
            closeChatModal();
        }
    });
    // --- End Chat Image Modal Logic ---

    // Function to handle processing and displaying a newly attached image (from upload or drag/drop)
    async function processAndDisplayAttachedImage(file) {
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                pendingImageBase64 = e.target.result;
                lastBotImageUrl = null; // New user upload clears any previous bot image context
                addMessage("Image selected. Type a prompt or send to use it.", 'user', pendingImageBase64);
                if (chatTextInput) chatTextInput.focus();
            };
            reader.readAsDataURL(file);
             // Reset file input if it was used, to allow re-uploading the same file
            if (chatImageUpload) chatImageUpload.value = '';
        } else if (file) {
            addMessage("Please attach an image file.", 'bot');
        }
    }

    // Handle sending a message (text or text after image upload)
    async function handleUserTurn(text) {
        let imageContextForNextTurn = null;

        if (pendingImageBase64) {
            imageContextForNextTurn = pendingImageBase64; // This is a base64 data URI
            lastBotImageUrl = null; // New user upload takes precedence
        } else if (lastBotImageUrl) {
            imageContextForNextTurn = lastBotImageUrl; // This is a direct URL
        }
        
        pendingImageBase64 = null; // Clear pending user upload after deciding context

        // If there's no text and no image context, do nothing.
        // If there IS an image context, we always want to send, even if text is empty,
        // as the backend might have a default action or prompt the user.
        // However, for a better UX, let's require text if there's no image context.
        if (!text && !imageContextForNextTurn) {
            // Optionally, tell user to type something if no image context
            // addMessage("Please type a message or upload an image.", "bot");
            return;
        }
        // If there's an image context, but no text, the backend will decide what to do.
        // (e.g., "What would you like to do with this image?")

        if (text) {
            const userMessageDiv = addMessage(text, 'user');
            // Set the parameters on the user message for potential editing
            if (userMessageDiv) {
                userMessageDiv.dataset.imageContext = imageContextForNextTurn || '';
                userMessageDiv.dataset.aspectRatio = chatAspectRatio ? chatAspectRatio.value : '1:1';
                userMessageDiv.dataset.model = chatModelSelect ? chatModelSelect.value : 'black-forest-labs/flux-kontext-pro';

                
                // Add edit icon to the user message
                const editIcon = document.createElement('span');
                editIcon.classList.add('edit-icon');
                editIcon.title = 'Edit Prompt';
                editIcon.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                        <path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                    </svg>
                `;
                editIcon.onclick = (e) => {
                    e.stopPropagation();
                    handleEditPrompt(userMessageDiv);
                };
                userMessageDiv.appendChild(editIcon);
            }
        }
        // User-uploaded image is added to UI when selected.

        if (chatTextInput) chatTextInput.value = '';
        if (chatTextInput) chatTextInput.style.height = 'auto';

        showBotTypingIndicator(true);

        try {
            const payload = {
                action: 'chat_message',
                text: text || '', // Send empty string if no text but there's an image context
                image_context: imageContextForNextTurn, // Can be base64 data URI or a URL
                aspectRatio: chatAspectRatio ? chatAspectRatio.value : '1:1',
                model: chatModelSelect ? chatModelSelect.value : 'black-forest-labs/flux-kontext-pro'
            };

            const response = await fetch('backend/api.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            showBotTypingIndicator(false); // Hide before processing response

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Network response was not ok.' }));
                addMessage(`Error: ${errorData.message || response.statusText}`, 'bot');
                return;
            }

            const data = await response.json();

            if (data.status === 'success') {
                addMessage(
                    data.botText,
                    'bot',
                    data.botImageUrl || null,
                    data.botImageUrl
                        ? {
                            text: text || '',
                            imageUrl: imageContextForNextTurn,
                            aspectRatio: chatAspectRatio ? chatAspectRatio.value : '1:1'
                        }
                        : null
                );
                if (data.botImageUrl) {
                    lastBotImageUrl = data.botImageUrl;
                }
            } else {
                addMessage(`API Error: ${data.message || 'Unknown error'}`, 'bot');
            }

        } catch (error) {
            showBotTypingIndicator(false);
            console.error('Error sending message:', error);
            addMessage('Sorry, something went wrong while contacting the bot.', 'bot');
        }
    }

    // Function to handle retry
    async function handleRetry(botMessageDiv) {
        // Read the parameters from the message's data attributes
        const prompt = botMessageDiv.dataset.prompt || '';
        const imageContext = botMessageDiv.dataset.imageContext || '';
        const aspectRatio = botMessageDiv.dataset.aspectRatio || (chatAspectRatio ? chatAspectRatio.value : '1:1');

        if (!prompt) {
            addMessage("No previous prompt found to retry.", 'bot');
            return;
        }

        // Remove the message being retried
        botMessageDiv.remove();

        showBotTypingIndicator(true);

        try {
            const payload = {
                action: 'chat_message',
                text: prompt,
                image_context: imageContext,
                aspectRatio: aspectRatio,
                model: chatModelSelect ? chatModelSelect.value : 'black-forest-labs/flux-kontext-pro',
                is_retry: true
            };

            const response = await fetch('backend/api.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            showBotTypingIndicator(false);

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Network response was not ok.' }));
                addMessage(`Error: ${errorData.message || response.statusText}`, 'bot');
                return;
            }

            const data = await response.json();

            if (data.status === 'success') {
                addMessage(data.botText, 'bot', data.botImageUrl || null, {
                    text: prompt,
                    imageUrl: imageContext,
                    aspectRatio: aspectRatio
                });
                if (data.botImageUrl) {
                    lastBotImageUrl = data.botImageUrl;
                }
            } else {
                addMessage(`API Error: ${data.message || 'Unknown error'}`, 'bot');
            }

        } catch (error) {
            showBotTypingIndicator(false);
            console.error('Error retrying:', error);
            addMessage('Sorry, something went wrong while retrying.', 'bot');
        }
    }

    // Function to handle editing prompt
    function handleEditPrompt(userMessageDiv) {
        const originalPrompt = userMessageDiv.dataset.prompt || '';
        const imageContext = userMessageDiv.dataset.imageContext || '';
        const originalAspectRatio = userMessageDiv.dataset.aspectRatio || (chatAspectRatio ? chatAspectRatio.value : '1:1');
        const originalModel = userMessageDiv.dataset.model || (chatModelSelect ? chatModelSelect.value : 'black-forest-labs/flux-kontext-pro');

        // Create edit modal
        const editModal = document.createElement('div');
        editModal.id = 'editPromptModal';
        editModal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;

        modalContent.innerHTML = `
            <h3 style="margin-top: 0;">Edit Prompt</h3>
            <div style="margin-bottom: 15px;">
                <label for="editPromptText" style="display: block; margin-bottom: 5px; font-weight: bold;">Prompt:</label>
                <textarea id="editPromptText" rows="4" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; resize: vertical;">${originalPrompt}</textarea>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="editAspectRatio" style="display: block; margin-bottom: 5px; font-weight: bold;">Aspect Ratio:</label>
                <select id="editAspectRatio" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    <option value="match_input_image" ${originalAspectRatio === 'match_input_image' ? 'selected' : ''}>Match input (or 1:1)</option>
                    <option value="4:3" ${originalAspectRatio === '4:3' ? 'selected' : ''}>4:3</option>
                    <option value="16:9" ${originalAspectRatio === '16:9' ? 'selected' : ''}>16:9</option>
                    <option value="9:16" ${originalAspectRatio === '9:16' ? 'selected' : ''}>9:16</option>
                    <option value="3:4" ${originalAspectRatio === '3:4' ? 'selected' : ''}>3:4</option>
                    <option value="3:2" ${originalAspectRatio === '3:2' ? 'selected' : ''}>3:2</option>
                    <option value="2:3" ${originalAspectRatio === '2:3' ? 'selected' : ''}>2:3</option>
                    <option value="4:5" ${originalAspectRatio === '4:5' ? 'selected' : ''}>4:5</option>
                    <option value="5:4" ${originalAspectRatio === '5:4' ? 'selected' : ''}>5:4</option>
                    <option value="21:9" ${originalAspectRatio === '21:9' ? 'selected' : ''}>21:9</option>
                    <option value="9:21" ${originalAspectRatio === '9:21' ? 'selected' : ''}>9:21</option>
                    <option value="2:1" ${originalAspectRatio === '2:1' ? 'selected' : ''}>2:1</option>
                    <option value="1:2" ${originalAspectRatio === '1:2' ? 'selected' : ''}>1:2</option>
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="editModelSelect" style="display: block; margin-bottom: 5px; font-weight: bold;">Model:</label>
                <select id="editModelSelect" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                    ${Array.from(chatModelSelect.options).map(option => 
                        `<option value="${option.value}" ${option.value === originalModel ? 'selected' : ''}>${option.text}</option>`
                    ).join('')}
                </select>
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="editCancelButton" style="padding: 8px 16px; border: 1px solid #ccc; background: #f5f5f5; border-radius: 4px; cursor: pointer;">Cancel</button>
                <button id="editApplyButton" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply & Regenerate</button>
            </div>
        `;

        editModal.appendChild(modalContent);
        document.body.appendChild(editModal);

        // Focus on the textarea
        const editPromptText = document.getElementById('editPromptText');
        editPromptText.focus();
        editPromptText.select();

        // Handle cancel
        document.getElementById('editCancelButton').onclick = () => {
            document.body.removeChild(editModal);
        };

        // Handle apply
        document.getElementById('editApplyButton').onclick = async () => {
            const newPrompt = editPromptText.value.trim();
            const newAspectRatio = document.getElementById('editAspectRatio').value;
            const newModel = document.getElementById('editModelSelect').value;

            if (!newPrompt) {
                alert('Please enter a prompt.');
                return;
            }

            // Remove the modal
            document.body.removeChild(editModal);

            // Update the user message text
            const textNode = userMessageDiv.querySelector('p');
            if (textNode) {
                textNode.textContent = newPrompt;
            }

            // Update the stored parameters
            userMessageDiv.dataset.prompt = newPrompt;
            userMessageDiv.dataset.aspectRatio = newAspectRatio;
            userMessageDiv.dataset.model = newModel;

            // Remove the previous bot response (the next message after this user message)
            const nextMessage = userMessageDiv.nextElementSibling;
            if (nextMessage && nextMessage.classList.contains('bot-message')) {
                nextMessage.remove();
            }

            // Show typing indicator
            showBotTypingIndicator(true);

            try {
                const payload = {
                    action: 'chat_message',
                    text: newPrompt,
                    image_context: imageContext,
                    aspectRatio: newAspectRatio,
                    model: newModel,
                    is_edit: true
                };

                const response = await fetch('backend/api.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload),
                });

                showBotTypingIndicator(false);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Network response was not ok.' }));
                    addMessage(`Error: ${errorData.message || response.statusText}`, 'bot');
                    return;
                }

                const data = await response.json();

                if (data.status === 'success') {
                    addMessage(data.botText, 'bot', data.botImageUrl || null, {
                        text: newPrompt,
                        imageUrl: imageContext,
                        aspectRatio: newAspectRatio
                    });
                    if (data.botImageUrl) {
                        lastBotImageUrl = data.botImageUrl;
                    }
                } else {
                    addMessage(`API Error: ${data.message || 'Unknown error'}`, 'bot');
                }

            } catch (error) {
                showBotTypingIndicator(false);
                console.error('Error editing prompt:', error);
                addMessage('Sorry, something went wrong while editing the prompt.', 'bot');
            }
        };

        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(editModal);
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);

        // Handle clicking outside modal
        editModal.onclick = (e) => {
            if (e.target === editModal) {
                document.body.removeChild(editModal);
                document.removeEventListener('keydown', handleEscape);
            }
        };
    }

    // Show/hide bot typing indicator
    function showBotTypingIndicator(show) {
        const typingIndicatorId = 'bot-typing-indicator';
        let typingIndicator = document.getElementById(typingIndicatorId);

        if (show && !isBotTyping) {
            if (!typingIndicator) {
                const indicatorDiv = document.createElement('div');
                indicatorDiv.id = typingIndicatorId;
                indicatorDiv.classList.add('message', 'bot-message', 'typing-indicator');
                indicatorDiv.innerHTML = '<p>Generating...</p>';
                chatMessages.appendChild(indicatorDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            isBotTyping = true;
        } else if (!show && typingIndicator) {
            typingIndicator.remove();
            isBotTyping = false;
        }
    }


    // Event listener for the main send button (text input)
    if (chatSendButton && chatTextInput) {
        chatSendButton.addEventListener('click', () => {
            const text = chatTextInput.value.trim();
            // Send if there's text OR a pending image (even if text is now empty)
            if (text || pendingImageBase64) {
                handleUserTurn(text);
            }
        });

        chatTextInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const text = chatTextInput.value.trim();
                if (text || pendingImageBase64) {
                    handleUserTurn(text);
                }
            }
        });
        // Auto-grow textarea
        chatTextInput.addEventListener('input', () => {
            chatTextInput.style.height = 'auto'; // Reset height
            chatTextInput.style.height = (chatTextInput.scrollHeight) + 'px'; // Set to scroll height
        });
    }

    // Handle image attachment button
    if (chatAttachImageButton && chatImageUpload) {
        chatAttachImageButton.addEventListener('click', () => {
            chatImageUpload.click();
        });

        chatImageUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processAndDisplayAttachedImage(file);
            }
        });
    }

    // Add Drag and Drop to chatInputArea
    if (chatInputArea) {
        chatInputArea.addEventListener('dragover', (event) => {
            event.preventDefault(); // Necessary to allow drop
            chatInputArea.classList.add('dragover-active');
        });

        chatInputArea.addEventListener('dragleave', (event) => {
            chatInputArea.classList.remove('dragover-active');
        });

        chatInputArea.addEventListener('drop', async (event) => {
            event.preventDefault();
            chatInputArea.classList.remove('dragover-active');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                await processAndDisplayAttachedImage(files[0]);
            }
        });
    }

    // Handle Start Over button
    if (chatStartOverButton) {
        chatStartOverButton.addEventListener('click', () => {
            chatMessages.innerHTML = '';
            pendingImageBase64 = null;
            lastBotImageUrl = null; // Clear last bot image on start over
            addMessage("Chat started. How can I help you today?", 'bot');
            if(chatTextInput) chatTextInput.value = '';
        });
    }

    // Initial bot message if chat is empty
    if (chatMessages && chatMessages.children.length === 0) {
         addMessage("Welcome to Conversational Editing! Describe what you want to create or edit, or upload an image to start.", 'bot');
    }
}); 