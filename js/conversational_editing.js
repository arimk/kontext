document.addEventListener('DOMContentLoaded', () => {
    const chatMessages = document.getElementById('chatMessages');
    const chatTextInput = document.getElementById('chatTextInput');
    const chatSendButton = document.getElementById('chatSendButton');
    const chatAttachImageButton = document.getElementById('chatAttachImageButton');
    const chatImageUpload = document.getElementById('chatImageUpload');
    const chatStartOverButton = document.getElementById('chatStartOverButton');
    const chatAspectRatio = document.getElementById('chatAspectRatio'); // Get aspect ratio dropdown
    const chatInputArea = document.querySelector('.chat-input-area'); // Get the chat input area

    // Modal elements for chat images
    const chatImageModal = document.getElementById('chatImageModal');
    const chatModalImage = document.getElementById('chatModalImage');
    const chatModalCloseButton = document.getElementById('chatModalCloseButton');
    // const chatModalCaption = document.getElementById('chatModalCaption'); // If using caption

    let isBotTyping = false; // To prevent multiple "typing" messages
    let pendingImageBase64 = null; // To hold user-uploaded image until text is sent
    let lastBotImageUrl = null; // To hold the URL of the last image generated by the bot

    // Function to add a message to the chat window
    function addMessage(text, type, imageUrl = null) {
        if (!text && !imageUrl) return; // Don't add empty messages unless it's an image-only message

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', `${type}-message`);

        if (text) {
            const textNode = document.createElement('p');
            textNode.textContent = text;
            messageDiv.appendChild(textNode);
        }

        if (imageUrl) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = (type === 'user') ? "User uploaded image" : "Bot generated image";
            img.style.maxWidth = '200px'; // Or some other appropriate size
            img.style.maxHeight = '200px'; // Ensure images don't get too tall
            img.style.objectFit = 'contain'; // Preserve aspect ratio within bounds
            img.style.borderRadius = '5px';
            img.style.marginTop = text ? '5px' : '0';
            messageDiv.appendChild(img);
        }

        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight; // Scroll to bottom
    }

    // --- Chat Image Modal Logic ---
    function openChatModal(imageUrl) {
        if (chatImageModal && chatModalImage) {
            chatModalImage.src = imageUrl;
            chatImageModal.style.display = "flex"; // Use flex for centering, or block
             // document.body.style.overflow = 'hidden'; // Prevent background scroll
        }
    }

    function closeChatModal() {
        if (chatImageModal) {
            chatImageModal.style.display = "none";
            chatModalImage.src = ""; // Clear image
            // document.body.style.overflow = 'auto'; // Restore background scroll
        }
    }

    // Event listener for chat messages container to handle clicks on dynamically added images
    if (chatMessages) {
        chatMessages.addEventListener('click', (event) => {
            if (event.target.tagName === 'IMG' && event.target.closest('.message')) {
                // Check if the image is not part of an action button or similar
                // For now, any image in a message is considered viewable.
                openChatModal(event.target.src);
            }
        });
    }

    // Event listener for modal close button
    if (chatModalCloseButton) {
        chatModalCloseButton.addEventListener('click', closeChatModal);
    }

    // Event listener for clicking outside the modal content (on the overlay) to close
    if (chatImageModal) {
        chatImageModal.addEventListener('click', (event) => {
            if (event.target === chatImageModal) { // Clicked on the overlay itself
                closeChatModal();
            }
        });
    }
    // Optional: Close modal on 'Escape' key press
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && chatImageModal && chatImageModal.style.display !== 'none') {
            closeChatModal();
        }
    });
    // --- End Chat Image Modal Logic ---

    // Function to handle processing and displaying a newly attached image (from upload or drag/drop)
    async function processAndDisplayAttachedImage(file) {
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                pendingImageBase64 = e.target.result;
                lastBotImageUrl = null; // New user upload clears any previous bot image context
                addMessage("Image selected. Type a prompt or send to use it.", 'user', pendingImageBase64);
                if (chatTextInput) chatTextInput.focus();
            };
            reader.readAsDataURL(file);
             // Reset file input if it was used, to allow re-uploading the same file
            if (chatImageUpload) chatImageUpload.value = '';
        } else if (file) {
            addMessage("Please attach an image file.", 'bot');
        }
    }

    // Handle sending a message (text or text after image upload)
    async function handleUserTurn(text) {
        let imageContextForNextTurn = null;

        if (pendingImageBase64) {
            imageContextForNextTurn = pendingImageBase64; // This is a base64 data URI
            lastBotImageUrl = null; // New user upload takes precedence
        } else if (lastBotImageUrl) {
            imageContextForNextTurn = lastBotImageUrl; // This is a direct URL
        }
        
        pendingImageBase64 = null; // Clear pending user upload after deciding context

        // If there's no text and no image context, do nothing.
        // If there IS an image context, we always want to send, even if text is empty,
        // as the backend might have a default action or prompt the user.
        // However, for a better UX, let's require text if there's no image context.
        if (!text && !imageContextForNextTurn) {
            // Optionally, tell user to type something if no image context
            // addMessage("Please type a message or upload an image.", "bot");
            return;
        }
        // If there's an image context, but no text, the backend will decide what to do.
        // (e.g., "What would you like to do with this image?")

        if (text) {
            addMessage(text, 'user');
        }
        // User-uploaded image is added to UI when selected.

        if (chatTextInput) chatTextInput.value = '';
        if (chatTextInput) chatTextInput.style.height = 'auto';

        showBotTypingIndicator(true);

        try {
            const payload = {
                action: 'chat_message',
                text: text || '', // Send empty string if no text but there's an image context
                image_context: imageContextForNextTurn, // Can be base64 data URI or a URL
                aspectRatio: chatAspectRatio ? chatAspectRatio.value : '1:1'
            };

            const response = await fetch('backend/api.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            showBotTypingIndicator(false); // Hide before processing response

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ message: 'Network response was not ok.' }));
                addMessage(`Error: ${errorData.message || response.statusText}`, 'bot');
                return;
            }

            const data = await response.json();

            if (data.status === 'success') {
                addMessage(data.botText, 'bot', data.botImageUrl || null);
                if (data.botImageUrl) {
                    lastBotImageUrl = data.botImageUrl; // Store the new bot image URL
                } else {
                    // If bot didn't return an image (e.g. text response),
                    // we might want to clear lastBotImageUrl or keep it, depending on desired flow.
                    // For now, let's clear it if no new image, to avoid accidentally reusing an old one
                    // if the conversation shifts away from that image.
                    // However, if the bot's text response is *about* the last image, keeping it might be better.
                    // Let's keep it for now, user can always upload a new one to override.
                }
            } else {
                addMessage(`API Error: ${data.message || 'Unknown error'}`, 'bot');
            }

        } catch (error) {
            showBotTypingIndicator(false);
            console.error('Error sending message:', error);
            addMessage('Sorry, something went wrong while contacting the bot.', 'bot');
        }
    }


    // Show/hide bot typing indicator
    function showBotTypingIndicator(show) {
        const typingIndicatorId = 'bot-typing-indicator';
        let typingIndicator = document.getElementById(typingIndicatorId);

        if (show && !isBotTyping) {
            if (!typingIndicator) {
                const indicatorDiv = document.createElement('div');
                indicatorDiv.id = typingIndicatorId;
                indicatorDiv.classList.add('message', 'bot-message', 'typing-indicator');
                indicatorDiv.innerHTML = '<p>Generating...</p>';
                chatMessages.appendChild(indicatorDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
            isBotTyping = true;
        } else if (!show && typingIndicator) {
            typingIndicator.remove();
            isBotTyping = false;
        }
    }


    // Event listener for the main send button (text input)
    if (chatSendButton && chatTextInput) {
        chatSendButton.addEventListener('click', () => {
            const text = chatTextInput.value.trim();
            // Send if there's text OR a pending image (even if text is now empty)
            if (text || pendingImageBase64) {
                handleUserTurn(text);
            }
        });

        chatTextInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const text = chatTextInput.value.trim();
                if (text || pendingImageBase64) {
                    handleUserTurn(text);
                }
            }
        });
        // Auto-grow textarea
        chatTextInput.addEventListener('input', () => {
            chatTextInput.style.height = 'auto'; // Reset height
            chatTextInput.style.height = (chatTextInput.scrollHeight) + 'px'; // Set to scroll height
        });
    }

    // Handle image attachment button
    if (chatAttachImageButton && chatImageUpload) {
        chatAttachImageButton.addEventListener('click', () => {
            chatImageUpload.click();
        });

        chatImageUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file) {
                await processAndDisplayAttachedImage(file);
            }
        });
    }

    // Add Drag and Drop to chatInputArea
    if (chatInputArea) {
        chatInputArea.addEventListener('dragover', (event) => {
            event.preventDefault(); // Necessary to allow drop
            chatInputArea.classList.add('dragover-active');
        });

        chatInputArea.addEventListener('dragleave', (event) => {
            chatInputArea.classList.remove('dragover-active');
        });

        chatInputArea.addEventListener('drop', async (event) => {
            event.preventDefault();
            chatInputArea.classList.remove('dragover-active');
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                await processAndDisplayAttachedImage(files[0]);
            }
        });
    }

    // Handle Start Over button
    if (chatStartOverButton) {
        chatStartOverButton.addEventListener('click', () => {
            chatMessages.innerHTML = '';
            pendingImageBase64 = null;
            lastBotImageUrl = null; // Clear last bot image on start over
            addMessage("Chat started. How can I help you today?", 'bot');
            if(chatTextInput) chatTextInput.value = '';
        });
    }

    // Initial bot message if chat is empty
    if (chatMessages && chatMessages.children.length === 0) {
         addMessage("Welcome to Conversational Editing! Describe what you want to create or edit, or upload an image to start.", 'bot');
    }
}); 